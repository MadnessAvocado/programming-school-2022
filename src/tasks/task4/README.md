# Задание №4
В прошлом задании вы наладили структуру приложения и познакомились с linux и git.
Теперь пришло время начать приводить в порядок ваши java файлы. Вы уже знаете, что
правильно определять один класс в одном файле. В большинстве случаев так и надо делать.
Собственно здесь расскажу про создание java проекта и использование множества классов.

## Знакомсто с gradle
1. Читаем что это за [зверь](https://ru.wikipedia.org/wiki/Gradle). Будет много незнакомых слов, их тоже полезно разобрать
2. Смотрим [гайд](https://docs.gradle.org/current/samples/sample_building_java_applications.html) о создании проекта.

В гайде по созданию проекта тоже много всего, в следующих занятиях разберёмся подробнее.
Gradle вообще очень мощный инструмент, но пока он нам нужен для создания проекта и его запуска.

Я создал проект [example](./example), в который добавил два класса `Foo` и `Bar`. Далее в классе
`App` создал объекты указанных классов и вызывал у обоих метод `sayHello`. Никаких импортов
для этого делать не нужно, так как все три класса находятся в одном [пакете](https://midbox.com.ua/rukovodstvo/java/chto-takoe-pakety-v-java) `example`.

## Создание собственного пакета
Теперь создайте ещё один пакет с названием `equation` в папке `main`. Добавьте в него класс `LinearEquationSolver`,
в котором реализован один метод - `solve(dobule a, dobule b)`. Вот [справка]() по линейным уравнениям.
Вас интересуют уравнения вида `ax = -b`. Собственно их метод и должен решать.

После вы можете смело добавить импорт в класс App:
```java
import equation.LinearEquationSolver;
```

Теперь вы можете использовать недавно созданный класс:
```java
LinearEquationSolver solver = new LinearEquationSolver();
solver.solve(2, -4);
```

Здесь может возникнуть вполне резонный вопрос: "Почему бы не сделать метод `solve` статическим ?".
Да, мы не используем состояние и статический метод здесь вполне может быть уместен.
Но из-за него мы отходим от ООП стиля, что в будущем может принести некоторые проблемы.
Хотя есть модули, которые полностью состоят из статических методов, например, `Math`.
Это особых проблем не приносит. В любом случае java не предназначена для работы с матешей, поэтому смело 
можете переделать метод в статический и сократить вызов до одной строки.

## Создание класса для решения квадратных уравнений
Здесь всё не так просто, ведь при отрицательном дискриминанте уравнение не имеет
решений в вещественных числах.

Есть множество подходов:
1. Вернуть `Dobule.POSITIVE_INFINITY`, но это не корректно
2. Кинуть ошибку, где сообщить о проблеме
3. Вернуть [комплексное число](http://www.mathprofi.ru/kompleksnye_chisla_dlya_chainikov.html)

Последний вариант звучит наиболее логично, но в java нет представления для
комплексных чисел :(

Давайте его добавим.

### Добавление комплексных чисел
Для начала определимся, как мы будем представлять комплексное число. Для этого
нам нужны вещественная и мнимая части. Кроме этого мы хотим печатать эти числа
в командную строку. В будущем нам придётся производить над ними арифметические
действия, для чего тоже понадобятся методы.

С задачей определились, теперь начинаем кодить. Создаём новый пакет в папке `main`, называем его
`model`. Далее создаём [запись](https://refactorfirst.com/what-are-java-records-in-java-16)
`ComplexNumber`.

```java
public record ComplexNumber(double r, double i) {}
```

### Решение вопроса с возвращаемым типом
Отлично, теперь у нас в любом случае есть решения уравнения, но есть ещё одна проблема -
решений может быть два. Как с этим будем поступать?
1. Можно вернуть массив, но с ним неудобно работать. Придётся делать проверки на длину, обращаться по индексу и бла-бла
2. Можно вернуть объект, который и содержит оба решения

Добавляем в пакет `model` запись `QuadraticEquationResponse`:

```java
public record QuadraticEquationResponse(ComplexNumber first, ComplexNumber second) {}
```

### Создание класса для решения квадратных уравнений
Предлагаю усложнить задачу. Теперь необходимо создать класс `QuadraticEquationSolver`,
который содержит метод:
```java
public static QuadraticEquationResponse solve(double a, double b, double c) {}
```

Реализуем метод, вызываем в классе `App` и радуемся завершению очередной таски)
