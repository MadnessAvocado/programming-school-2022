# Задание №5. Вливаемся в ООП

## Интерфейсы

### Теория

К счастью, за меня уже написана [статья про интерфейсы](https://javarush.ru/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih).
В ООП очень любят интерфейсы, почти всегда стоит создавать его, чем класс. В этом
вам предстоит убедиться не один раз)

В пакете [car](./example/app/src/main/java/example/car) подготовлен как раз класс `Car`, который зависит от двух интерфейсов:
`Engine` и `Electronics`. В пакете [car.impl](./example/app/src/main/java/example/car/impl) лежат имплементации данных интерфейсов.
Одна для `Electronics` и 2 для `Engine`.

### Практика
Создать вторую имплементацию интерфейса `Electronics`.

## Дженерики (Generics)

### Теория

Да кто эти ваши [дженерки](https://javarush.ru/groups/posts/2295-chto-takoe-dzheneriki-v-java) такие ?

### Практика

В нашем же случае предстоит переделать [задание №4](../task4).

По ходу его выполнения вы могли заметить, что классы для решения линейных и квадратных
уравнений в чём-то очень похожи. Оба метода для решения принимают данные на вход, на их
основании вычисляют ответ и возвращают его. Тут и наклёвывается абстракция над 'решателем 
уравнений'. 

Но сразу же возникает две проблемы:
1. Каждому уравнению нужны разные параметры (a и b для линейного, a, b, c для квадратного)
2. Каждое уравнение возвращает разные типы, линейное - `double`, а квадратное `QuadraticEquationResult`

Предлагаю решить их по порядку. Начнём с первой. Мы можем просто собрать все параметры
в единый объект, так называемый `DTO` (Data Transfer Object). Эти объекты служат только
для передачи данных, например, `QuadraticEquationResult`. Вторая проблема решается
аналогичным способом. Необходимо создать класс, который будет содержать единственное
поле - результат. Решение смотрите в пакете [equation.model](./example/app/src/main/java/example/equation/model)

Теперь наш метод для решения можно представить в следующем виде:
```java
Object solve(Object request);
```

Но у нас тема дженериков, поэтому мы прокачаем его:
```java
R solve(T request);
```

В данном случае, `R` описывает возвращаемый тип, а `T` - получаемый. Собственно
сам интерфейс можете посмотреть в пакете [equation](./example/app/src/main/java/example/equation/EquationSolver.java).

Как же этого индвида имплементировать? Для этого необходимо сделать следующий [финт ушами](./example/app/src/main/java/example/equation/impl/LinearEquationSolver.java).
В данном случае к интерфейсу добавляются знаки `<` и `>`, в которых и указываются типы для `T` и `R`.

### Практика

Добавьте указанные изменения в код для [задания №4](../task4).
Измените класс `QuadraticEquationSolver` так, чтобы он имплементировал
интерфейс `EquationSolver`.

## Паттерн Фабрика (Factory)

### Теория

Вот и пришло время узнать первый ООП паттерн. Фабрика является `порождающим` паттерном, это означает, что
главной целью является создание объектов. Используется она для унификации создания каких-либо
объектов. Например, нам периодически в коде нужно создавать вложенные объекты, например:

```java
var phone = new Phone(
        new Display(
                new Matrix(),
                new GPU(new Processor())
        ),
        new PhoneCase(
                new Plastic(),
                new Buttons()
        ),
        // И ещё 100500 объектов
);
```

Согласитесь, постоянно видеть такую историю не особо приятно, а писать в два раза неприятнее.
Вот для решения этой и нескольких других проблем человечество придумало фабрику.

Выглядит она следующим образом:
```java
public final class PhoneFactory {
    public Phone createPhone() {
        // Do Phone creation and return here...
    }
}
```

Теперь в нашем коде мы можем создавать телефон следующим образом:
```java
var factory = new PhoneFactory();
var phone = factory.createPhone();
```

Согласитесь, выглядит теперь намного короче. Кроме этого, если мы захотим изменить
конфигурацию для телефона, то нужно будет это сделать только в одном месте. Есть и
минусы у такого подхода - весь код, который использует `PhoneFactory`, работает с
одинаковым телефоном. Также для многих объектов нам необходимо писать собственные
фабрики. Эти задачи вам предстоит научиться решать в будущем.

Пример лежит в [car.factory](./example/app/src/main/java/example/car/factory)

### Практика

Добавить фабрику для линейного и квадратного уравнений в код [задания №4](../task4).


## Ещё один паттерн! Шаблонный метод или Template method

### Теория

Данный паттерн является поведенческим и позволяет реализовывать классы с одинаковой сигнатурой метода,
но разной логикой. Например, у нас есть штат из работников в какой-то компании.
Все они делают разную работу, но мы хотим, чтобы все они начинали работать в
одно время. И, кончено, не хотим вручную говорить каждому работать.

Для начала необходимо создать интерфейс, который определит некий контракт,
по которому мы общаемся с работниками. В нашем случае это [SuperDuperWorker](./example/app/src/main/java/example/worker/SuperDuperWorker.java),
в котором определён единственный метод `doWork`.

Теперь давайте наплодим наших рабочих: [AndreSuperDuperWorker](./example/app/src/main/java/example/worker/impl/AndreySuperDuperWorker.java)
и [SemenSuperDuperWorker](./example/app/src/main/java/example/worker/impl/SemenSuperDuperWorker.java).

Собственно осталось всем дать знать, что пора работать. Благодаря тому, что наши работники
реализуют один интерфейс, мы можем создать коллекцию из них.

```java
List<SuperDuperWorker> workers = List.of(
        new AndreySuperDuperWorker(),
        new SemenSuperDuperWorker()
);
```

Теперь итерируемся и вызываем метод `doWork`;

```java
for (var worker : workers) {
    worker.doWork();
}
```



### Практика